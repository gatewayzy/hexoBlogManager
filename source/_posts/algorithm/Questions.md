---
title: Question
comments: true
date: 2017-03-01 13:58:04
updated: 2017-03-01 13:58:04
categories: Algorithm
tags:
- Question
---

**说明：**常见问题。
<!-- more -->

---
* 参考文章：
	* [各种算法](http://blog.csdn.net/lyhvoyage/article/details/22926265)
	* 《剑指offer》
	* LeetCode


## 编程与算法
---
* 《设计模式》
	* 4位作者（全拼Gang of four，四人帮？）提出的面向对象的设计原则。
	* 核心观点：对接口编程而不是对实现编程；优先使用对象组合而不是使用继承。
* 设计模式四个方面：
	* 创建型模式：工厂模式、抽象工厂、单例、创造者、原型 （5）
	* 结构型模式：适配器、桥接、过滤器、组合、装饰器、外观、享元、代理 （8）
	* 行为型模式：责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、空对象、策略、模板、访问者 （12）
	* J2EE模式：MVC模式、业务代表、组合实体、数据访问对象dao、前端控制器、拦截过滤器、服务定位器、传输对象 （8）
* 设计模式6大原则：
	* 开闭原则：对拓展开放，对修改关闭。拓展时不能修改原有代码以实现热拔插。所以常用结构和抽象类进行抽象化。
	* 里氏代换原则LSP：任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。lsp是关闭原则的抽象化的具体步骤规范。
	* 依赖倒转原则：针对接口编程，依赖于抽象而不依赖于具体。是关闭原则的基础。
	* 接口隔离原则：使用多个隔离的接口，降低类之间的耦合性。
	* 最少知道原则：一个实体应尽量少地与其他实体发生相互作用，提高相对独立性。
	* 合成复用原则：尽量使用合成、聚合的方式，而不是使用继承。


* 对一个链表进行操作，（剑指offer）
	* 如何查找中间的结点且时间O阶为O(n)？ 
		* 使用两个指针指向头部，第一个+1，第二个+2，先到尾部的时候第一个就到中间了
	* 如何输出1，8,2,7,3,6的顺序？ 
		* 使用上面的两个指针，到第二个到尾部之后，1号向尾部，2号向头部输出
	* 如何判断链表是否存在环？ 
		* 使用两个指针，1号加1，二号加2，一直循环，如果出现二者重合说明存在环，比如最后两个相互指向的情况。
	* 如何输出环出现的入口结点？ 
		* 上面两个指针出现p1==p2则找到在环中的相汇点。
		* 当p1==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走一圈有2x=n+x; n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1==p2; 此时p1指向环的入口。

## 单例模式

* 只支持单线程的方法：类的一个static getInstance（）
* 支持多线程但加锁消耗太多的方法：
* 支持多线程并改进加锁消耗的方法：
* 静态方法自动加载的方法：private static T instance = new T()  ...getInstance() {return instance;}
* 静态内部类掉用时才创建的方法：class T { class Y{public static T instance = new T()} public static getInstance() {return Y.instance;}


## 深搜广搜
---
* 计算hit转cog要多少步，每次只能变1个，只能用hot，dot，dog，lot，log，示例hit，hot，dot，dog，cog是5步
* 树中，出现各个路径或者遍历就应该考虑用栈
	* 如：求各个路径上的和、遍历整个树。
* 用队列实现栈、用栈实现队列问题？
	* 两个队列实现栈：栈的push就是一个队列正常队尾入队，栈的pop就是将所有数据从头出并从另一个队尾进且不添加最后一个，然后将另一个队尾的数据再全部出队并入队到原队列中。
	* 两个栈实现队列：队列的入队就是一个栈的正常入栈，队列的出队就是栈全部pop并push到栈B，栈Bpop出一个数据就是出队，然后将栈B再全部pop并push到原栈。通过画一下栈和队列的出入方向，写一下abc示例一下就清楚了。


## 未分类
---
* 浮点型数据进行比较是否为0的时候，不能用 a==0 进行判断！使用Math.abs(a)<1e-6 之类的小数进行控制。
* 求n个连续的x(1-9)构成的数字能被y(int)整除，其中x，y是给定的，求最小的n，比如求n个1能被3整除，输出n=3表示111能被3整除。如果是9个1被9整除就会int溢出。
	* 两个数都对m取模，余数相同的话，那么这两个数字同余。思路就是，每次取模之后，不用temp*10+x对m取模，而是用temp上次对m取模得到的余数乘10+x 然后对m取模。。。反正就是两个数对m取模得到的数相同的话，那么这两个数等价。要把所有的数字映射到1-m之间？？
* 真假村子：A村人说假话，B村人说真话，怎么问一个人才知道自己是不是在A村
	* 不和你同一个村子的人说这是A村：假设自己是在A，如果他是A的，那么他会说不是，如果他是B的他会说不是（假话），同理自己不在A他们会说是。本质是一个异或问题。
* 坐标计算一个点是否在一堆点中间？
	* Cn3解法：查找所有三角形，判断是不是在三角形内部
		* 三角形角度判断法：三角形与该点连线的三个夹角都不能大于180，用cos、sin求解，问题是如何表示正确表示三个角，而不是第三个角是前两个角的和。
		* 三角形面积判断法：该点与三个顶点相连构成的三个小三角形面积与外三角形面积相比，如果原面积与三个小面积之差绝对值接近于0则在内部。
	* Cn2解法：将该点相对移动到原点，连接所有线段，必经过所有4个象限才能围住，问题是如何判断一条线段经过哪几个象限，如不同象限11,12,13,14的四个线段经过哪几个象限
* 24点问题：四个数如8833,7744
	* 选取两个数处理得到一个数，将该数和其余两个数进行递归处理，每次处理两个数。既然是递归，就应该能想到用栈，因为递归本身就栈实现的，那么就可以全入栈，不断出栈处理。

## 动态规划 Dynamic Programming
---
* dp问题是很重要的一类问题，关键在于状态定义和状态转移方程的书写，然后才是算法实现。

### 背包问题
---
* 问题描述：用一个承受重量m的背包装货物，每个货物不同的重量weight和价值value，求解可以装货的最大价值。这里我们讨论0-1背包问题。
* 问题解析：背包问题属于NP问题，也是典型的动态规划问题。每个货物至多装一个就是0-1背包。每个货物可以装count(i)个就是有界背包。每个货物可以装无限多个就是完全背包问题，无界背包问题。
* 状态定义与状态转移方程：
	* 状态定义为dp[i][j]，表示前i个货物总重不超过j的情况下所含有的最大价值。
	* 状态转移过程为：前i-1个已经确定装不装之后，当前货物装或者不装两种情况使用j所能对应的最大价值。
	* 状态转移方程为 dp[i][j] = max(dp[i-1][j] ,value[i] + dp[i-1][j-weight[i]] )。
* 每决定当前这个装不装就是两个转移路径，对应着两个价值。
```bash
	/**
	 * 使用动态规划求解背包问题
	 * 
	 * @param m 要求的容量是m
	 * @param w weight
	 * @param v value
	 */
	public static void solution(int m, int[] w, int[] v) {
		System.out.println(Arrays.toString(w));
		System.out.println(Arrays.toString(v));
		int n = w.length;
		int[][] dp = new int[n + 1][m + 1];
		// 初始化，数组元素相当于对象的成员变量，所以默认会自动初始化
		// 进行dp推算
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (j >= w[i-1]) { // 如果能够装下当前这个，就是转移方程：max（添加、非添加时对应的状态）
					dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i-1]);
				}else{
					// 装不当前这个，就是前i-1的value
					dp[i][j] = dp[i-1][j]; 
				}
			}
		}
		System.out.println(dp[n][m]);

	}

```






## 查找
---


