---
title: Data Structure
comments: true
date: 2017-03-01 13:58:04
updated: 2017-03-01 13:58:04
categories: Algorithm
tags:
- 数据结构
---

**说明：**数据结构概论，常用算法。
<!-- more -->

---
* 参考文章：
	* 《大话数据结构》
	* 《算法导论》

## 数据结构
---
* 逻辑结构：集合结构、线性结构、树形结构、图形结构
* 物理结构：
	* 顺序存储结构：内存连续，直接计算前后地址（支持随机存取）。要提前指定空间大小并考虑溢出问题，快速高效，不适合元素频繁移动的情况
	* 链接存储结构：内存不连续，使用指针等链接起来。不考虑大小，适合元素移动，但是需要额外空间实现遍历，查找不够快速
* 每个逻辑结构都可以用不同的物理结构实现。
	* 内存申请与释放需要进行malloc、free操作。

## 算法
---
* 算法复杂度
	* 时间复杂度与空间复杂度，一般默认指时间复杂度
	* 时间复杂度与空间复杂度一般需要进行折中考虑
	* 复杂度的计算主要依靠数学能力。
* 算法时间复杂度
	* 推导方法：求出语句执行次数关于问题规模的函数，选取增长率最快的并将系数取1。
	* 常用O阶：O(1)<O(log(n))<O(n)<O(nlog(n))<O(n*n)<...一般高于n方的就算太高了。
	* 最坏情况与最好情况：分别可以求出一个最好O阶和最坏O阶。
	* 根据所有情况的概率分布也可以求出一个平均运行时间。
	* 一般时间复杂度是指最坏时间复杂度。

* 算法空间复杂度
	* 推导方法：求出程序占用空间关于问题规模的函数，选取增长率最快的并将系数取1。
	* 其他内容与算法时间复杂度类似。

## 线性表
---
* 定义：0或多个数据元素的有限序列（每个数据元素可能含有多个数据项）

### 用顺序存储结构实现线性表
---
* 顺序存储结构存储，如数组array
* 优点：容易计算相对位置，查找迅速O(1)
* 缺点：改删元素需要内存连续性整理，需要考虑空间溢出与重新分配，太多的顺序结构可能造成内存碎片。

### 用链式存储结构实现线性表
---
* 用链式存储结构存储，如列表List

#### 单链表

* 头指针与头结点的异同
	* 头指针指向链表第一个结点，如果有头结点就指向头结点。头指针不能为空，常用链表名标识整个链表
	* 头结点是为了操作统一和方便而设立的，放在第一个元素之前，多数是存在的，便于统一在第一个数据结点插入数据的操作统一。
* 链表操作
	* 增查改删等
	* 查找要从头找，复杂度O(n)
	* 插入时有头插法和尾插法，头插法就是新插入的结点放在第一个位置，尾插法就是放在尾部。
	* 删除时就是从头一直往后删，释放内存。

#### 静态链表

* 静态链表：用数组实现的链表
* 方法：数组中每个对象有数据域和指针域（游标），指针域用于指向下一个链表结点。
* 优点：插入和删除只需要修改游标，不需要移动元素
* 缺点：失去原有数组结构的随机存取特征，需要考虑元素溢出时的内存申请问题。

#### 循环链表

* 循环链表定义：将单链表的尾部结点的null指针改为指向头结点，就是一个头尾相接的单循环链表，简称循环链表。
* 如果需要方便查找尾结点，可以将头指针改成尾指针，每次从尾部节点开始。

#### 双向链表

* 定义：在单链表的每个结点中添加一个指向前向结点的指针域就构成双线链表。

#### 双向循环链表

* 将双线链表的头尾互联。

## 栈与队列
---
### 栈
---
* 栈定义：只允许在表位进行插入和删除操作的线性表。
* 栈的特性：栈顶，栈底，出栈入栈，后进先出LIFO（last in first out）
* 具体实现示例如下。

```
Stack<Integer> stack = new Stack<>();  // java.util.Stack
stack.push(1);
stack.push(2);

System.out.println(stack.peek()); // peek 获取栈顶元素，不会进行删除操作
System.out.println(stack.pop());  // pop 获取栈顶元素，并从栈顶删除
System.out.println(stack.size() + "\t" + stack.isEmpty()); //还有clear等和扩展实现的get、contains等
```
#### 用线性存储结构实现栈

* 用数组实现栈操作，a[0]存放栈底，后面的作为栈顶，以方便实现入栈出栈。
* 两个栈共享空间：将两个栈用同一个数组实现，数组两端分别做为两个栈底，栈向中间增长。适合于一个增那么另一个就减的情况。

#### 用链式存储结构实现栈

* 栈的链式存储结构简称为链栈。
* 可以用链表实现，只允许在链表尾部进行操作即可。

#### 栈的应用--递归

* 栈经常用于递归的实现。
* 例如对于斐波那契，列出可以用简单的迭代和递归进行实现
	* 迭代：使用两个中间变量，从a0和a1循环迭代a[i-2]+a[i-1] = a[i] 直到目标。（迭代通过循环结构进行控制）
	* 递归：调用自身，使用递归退出条件。（递归通过条件结构进行控制）
* 迭代与递归的优缺点
	* 迭代不会占用额外的空间，不会反复调用函数本身，时间和空间比递归要好。但是设计要求也高一点。
	* 递归会大量复制自身代码，占用大量的时间和内存，时间和空间都差，每一层迭代的局部变量、参数值和返回地址都会入栈，结束后再出栈接着执行该层递归的剩余代码。递归的好处在于设计实现起来简单。

#### 栈的应用--四则运算表达式求值

* 中缀表达式就是平常写的加减乘除和括号的式子，后缀表达式就是不需要括号，将符号写在数字后面的式子（又叫后波兰表达式）。
* 用栈进行四则表达式的求值的过程为：
	* 将中缀表达式转化为后缀表达式（栈用于进出符号）。
	* 将后缀表达式计算出结果（栈用于进出数字）。
* 中缀表达式转后缀表达式
	* 遇到数组则直接输出。
	* 遇到符号，如果优先级比栈顶符号高，则入栈；如果优先级比栈顶的低，则出栈并输出。
		* 若是右括号则进行出栈和输出，直至左括号出栈。（不输出左括号，且右括号不入栈）
		* 若是左括号则入栈。
	* 从左向右处理原来表达式，输出结果连起来就是后缀表达式。如`9+(3-1)*3+10/2` 的后缀表达式为 `9 3 1 - 3 * + 10 2 / +` 。为了分开数字与数字，需要生成输出时输出空格。
* 计算后缀表达式的值
	* 遇到数字则入栈
	* 遇到符号则出栈两次，将三者计算结果入栈
	* 直至从左向右计算完成可以得到最后结果。

### 队列
---
* 队列定义：只允许在一端插入、而在另一端删除的线性表。
* 队列特性：队尾插入、队首删除、先进先出（FIFO）
* 具体实现如下所示。

```
Queue<Integer> queue = new LinkedList<>();  // java.util.LinkedList实现了queue接口
queue.add(1);
queue.add(2);

System.out.println(queue.peek());    // peek 获取队首，不会删除
System.out.println(queue.poll());    // poll 获取并删除队首，空队会返回null
System.out.println(queue.remove());  // remove 获取并删除队首，空队会抛出异常
```

#### 用顺序存储结构实现队列

* 朴素的用数组实现队列：一头入队，另一头出队。
	* 缺点在于数组会出现假溢出，头部被删除的空间并没有利用上。
* 循环队列：使用头尾相接的顺序存储结构实现的队列。
	* 用front和rear两个指针分别指向头结点和结尾元素的下一个节点
	* 二者相等说明可能是空队列或者队列已满，队列长度计算方式为：（rear-front+QueueSize）%QueueSize
	* 优点：适合用于队列最长长度确定的情况，
	* 缺点：队列不满时有空间浪费，队列过长时需要重新申请内存。

#### 用链式存储结构实现队列

* 用线性表的单链表实现队列，一端进另一端出，这种也简称为链队列。
* 单链表只允许头部进，尾部出，所以队列基本操作的时间复杂度也是O(1)。
* 链队列适合长度不好估计的情况，如果长度确定则应考虑用循环队列。

## 串
---

* 串、空串
* 串的存储结构：
	* 顺序存储结构：数组存储字符，最后添加一个'\0'作为结束表示（性能最好，一般用顺序存串）。
	* 链式存储结构：链表存储：单链表的元素是多个字符。 

### 串的模式匹配算法
---
串中经常的之一就是模式匹配：从主串中查找子串的位置。

#### 朴素的模式匹配

* 方法是使用主串每一个字符作为子串开头，与子串进行匹配。
* 需要强制实现二重循环匹配，缺点在于很多失败的匹配信息没有利用上。

#### KMP模式匹配算法

* KMP是三个人的字母，KMP算法能够大大避免重复遍历的情况。当子串中重复部分比较多时，性能优势越明显。
* 朴素的KMP算法，核心思想就是主串的循环不进行回退，用相应的j进行控制。
	* 对子串进行计算next数组
	* 根据子串的next的数组对主串进行匹配
* next数组的计算
	* 计算方法：
		* next[j]=0，当j=1时
		* next[j]=Max{k | 1<k<j, 且‘P1...Pk-1’=‘Pj-k+1...Pj-1’} 当此集合不为空时
		* next[j]=1，在其他情况下
	* 示例：子串ababaaaba的next数组
		* j=1，next[1]=0，对应a
		* j=2，前面部分是a，不能前后缀相同，next[2]=1;
		* j=3，前面部分是ab，不能前后缀相同，next[3]=1
		* j=4，前面部分是aba，最长相同是a与后面的a，next[4]=2(1个a+1)
		* j=5，前面部分是abab，最长相同是ab与后面的ab，next[5]=2+1=3
		* j=6，前面部分是ababa，最长相同是aba与后面的aba，next[6]=3+1=4
		* 类推，得到 next[j] = 011234223

* 改进的KMP算法
	* 算法
		* 对子串计算next数组，同时，如果子串a位上的字符与他next值指向的b字符相等，则该a位的nextval的值设为b位的nextval值，如果不等则a的nextval就保留自己的next值。
		* 根据子串的nextval数组对主串进行匹配
	* 示例：子串ababaaaba的nextval数组
		* j=1，next[1]=0，nextval[1]=0
		* j=2，next[2]=1，子串1对应的是a，不等于当前2上的b，nextval[2]=next[2]=1
		* j=3，next[3]=1，子串1对应的是a，等于当前3上的a，nextval[3]=next[1]=0
		* j=4，next[4]=2，子串2对应的是b，等于当前4上的b，nextval[4]=next[2]=1
		* 类推，得到nextval[j] = 010104210

## 树
---
* 树的递归定义、结点分类、森林：0个或多个不相交的树的集合

### 树的存储结构
---
* 树的存储结构：用顺序存储比较麻烦，用链接存储比较方便
* 树的表示方式：
	* 双亲表示法
	* 孩子表示法
	* 孩子兄弟表示法

### 二叉树
---
#### 基本知识

* 概念
	* 二叉树：所有结点至多2个孩子结点。
	* 斜树：所有结点都只有一个方向的子结点，左斜树右斜树
	* 满二叉树：所有分支结点都有2个子结点。
	* 完全二叉树：所有结点的编号与相应深度的满二叉树中的结点按层编号的结果一致。
* 二叉树的性质：结点树、树的高度等
* 二叉树的存储结构
	* 线性存储结构：二叉树由于结构特殊，用线性存储实现还是比较方便的，但是一般也只用于完全二叉树。
	* 链式存储结构：用链表存储二叉树，又叫二叉链表。

#### 遍历二叉树

* 遍历二叉树
	* 前序遍历：根节点--前序遍历左子树--后续遍历右子树
	* 中序遍历：中序遍历左子树--根节点--中序遍历右子树
	* 后序遍历：后续遍历左子树--后序遍历右子树--根节点
	* 层次遍历：一层一层从左向右
* 遍历的实现：方法1 递归 方法2 用栈实现
	* 根据中序遍历、前序遍历可以确定一棵二叉树
	* 根据中序遍历、后续遍历可以确定一棵二叉树
	* 但是由前序和后序遍历不能确定一个二叉树
* 树、森林、二叉树的转换
	* 树转化为二叉树；加线、去线、层次调整
	* 森林转化为二叉树：树转化为二叉树、树的根节点作为左边树根节点的右结点
	* 二叉树转换为树：加线、去线、层次调整
	* 二叉树转化为森林：断开根节点的顶层右结点，将各个二叉树转为树
* 树的遍历：
	* 先根遍历
	* 后根遍历
* 森林的遍历：
	* 前序遍历
	* 后序遍历

#### 赫夫曼树（最优二叉树）

* 赫夫曼树
	* 路径长度：从根节点到目标结点间的分支树，如根节点到其子结点的路径长度为1
	* 树的路径长度：从根节点到所有叶子结点的路径长度之和
	* 带权路径：计算路径时计算上相应的权值
	* **赫夫曼树：带权路径最小的二叉树**
	* 赫夫曼树的生成：选取最小的2个值构成二叉树，其权值之和与其余数值进行比较，再选取最小的2个值构成二叉树，直到完整一棵树
	* 赫夫曼编码：将各个字母作为叶子结点，根据使用频率构造赫夫曼树，用0和1表示左右，从根节点到该结点的路径作为编码，可保证总的加密文本尽量短

## 图
---
### 概念
---
* 图的定义：由顶点的有穷非空集合和顶点之间边的集合组成，常记为G(V,E)，G表示图，V表示顶点的集合，E表示边
* 无向图：无向边(A,B)，有向图:有向边<A,B>
* 简单图：不含有指向自身的边，同一条边不重复出现。无向（有向）完全图：顶点间全连接。
* 网：边上带权的图
* 子图，出度，入度
* 回路（环），简单路径，简单回路/简单环
* 连通图：任意两点间都连通的。有向图中均连通则叫强联通图
* 子图极大连通则为该图的连通分量，有向的则称为强连通分量
* 生成子图：无向图中连通所有的n个结点且只含有n-1条边的连通子图
* 有向树：有向图中一顶点入度为0，其余顶点入度为1

### 图的存储结构
---
* 图是逻辑上的，不管用顺序存储还是链式存储都比较复杂
* 图的存储表示方法：
	* **邻接矩阵**：  用一个数组存放顶点，用一个二维数组存放顶点之间是否连通或者路径距离（常用于最短路径、最小生成树）
	* **邻接表**： 数组存放顶点，顶点后面使用链表存放该点相连的顶点（常用于拓扑排序等需要添加/删除节点的情况）
	* 十字链表
	* 邻接多重表
	* 边集数组： 一个数组存放顶点，一个二维数组存放各个边的起始顶点、终止顶点、边的权值

### 图的遍历
---
* 图的遍历：从一个顶点出发并只访问一次其余的所有顶点。
* 一般方法是设置一个数组标记顶点是否被访问过。

#### 深度优先搜索 DFS

* 深度优先搜索 depth first search（深度优先遍历），类似于图的先序遍历
* 思想：
	* 从图中一个节点出发，访问此顶点，然后对其未被访问过的邻接点进行DFS递归，直至所有点都被访问过
	* 如果图是不连通的，则另选图中一个未被访问过的顶点进行DFS，直至所有点都被访问过

#### 广度优先搜索 BFS

* 广度优先搜索 Breadth first search（广度优先遍历），类似于图的层序遍历
* 思想：
	* 
* 深搜与广搜在时间复杂度上是一样的，在全图遍历上没有太多差别。但是由于顶点访问顺序不同，可能有不同的应用
* 常用场景：
	* 计算A与B之间最短路径、最短距离，一般用广搜


### 最小生成树

* 构造连通网的最小代价生成树称为最小生成树
* 用来解决同样问题的有Prim算法、Kruskal算法、Boruvka算法等。三种算法都是贪婪算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。

#### Prim算法生成最小生成树
	
* 算法流程
	* 从一个顶点开始，放进点集合中
	* 查找不在点集合中的所有点到点集合中各点权值最小的边，记录该边，并将对应点加入点集合
	* 最后点集合会包含所有顶点，与记录的边构成最小生成树
* 时间O阶为：邻接矩阵O（v*v） 邻接表O(elog(v)) ,e是边数，v是顶点数

#### Kruskal算法生成最小生成树
	
* 算法
	* 记Graph中有v个顶点，e个边
	* 新建图Graphnew，Graphnew中拥有原图中相同的e个顶点，但没有边
	* 将原图Graph中所有e个边按权值从小到大排序
	* 循环：从权值最小的边开始遍历每条边 直至图Graph中所有的节点都在同一个连通分量中
		* if 这条边连接的两个节点于图Graphnew中不在同一个连通分量中，添加这条边到图Graphnew中
		* 否则放弃该边，选择下一条权值小的边。类推，直至所有顶点都在同一个连通分量上
* Kruskal算法主要是针对边的，时间O阶是O(elog(e))其中e是边数，在边很少时效率很高，适用于稀疏图。对于稠密图，Prim算法更好些。

### 最短路径
---
* 最短路径就是网图中从源点到终点经过的边上权值之和最少的路径。
* Dijkstra算法、A*算法、SPFA算法、Bellman-Ford算法和Floyd-Warshall算法等

#### Dijkstra 算法



#### Floyd 算法

#### Bellman-Ford

#### SPFA

#### A*算法

### 拓扑排序
---
* AOV网络：顶点表示活动，弧表示活动之间的优先级的有向图。Activity On Vertex Network （vertex顶点） 
* 拓扑序列：若从Vi顶点到Vj顶点有路径的话，在顶点排序中顶点Vi必须在Vj之前。
* 拓扑排序：对有向图构造拓扑序列。
* 算法思想：从AOV网络中选取入度为0的顶点输出，删除此顶点，删除此顶点出发的弧。重复上面的步骤，直到输出所有顶点或者没有入度为0的顶点。
* 由于排序要删除顶点，因此使用邻接表更加方便。 

* 算法实现：
	* 查找所有入度为0的顶点，入栈（避免重复查找每个每次删除之后都去查找入度为0的点）
	* 出栈并进行输出、删除、删除弧操作，更新弧终点的入度，入度改变为0的话则入栈
	* 重复上一步，直至栈为空


### 关键路径
---

* AOE网络：带权有向图中，顶点表示事件，有向边表示活动，权值表示活动持续时间，这种网叫AOE网。Activity On Edge Network
* 路径长度：路径上各个活动持续的时间之和
* 关键路径：从源点到汇点（终点）的路径长度最大的路径。路径上的活动叫关键活动。

* 算法实现：

## 查找
---
### 概念
---
* 查找的关键字、主关键字、次关键字
* 静态查找表：查找时不改变原表，动态查找表：查找过程中插入或删除数据。
* 部分查找算法的复杂度

|分类|算法	|最坏查找O阶	|最坏插入O阶	|最坏删除O阶	|平均查找O阶	|平均插入O阶	|平均删除O阶	|数据是否Ordered存放	|思想	|
|::	|::	|::	|::	|::	|::	|::	|::	|::	|::	|	
|**顺序表查找**	|顺序表查找	|n	|n	|n	|n	|n	|n	|否	|对无序表一个一个查找|
|**有序表查找**	|二分查找	|log(n)		|n	|n	|log(n)		|n	|n	|是	|对有序表进行划分查找，二分、插值、斐波那契等查找
|**线性索引查找**	|稠密索引、分块索引、倒排索引	|		|		|		|		|		|		|	|建立索引表，稠密索引、分块索引、倒排索引等
|**二叉查找树**	|BST二叉查找树	|n	|n	|n	|log(n)		|log(n)		|?	|是	|树的形状与插入顺序有关，没有平衡调节，可能偏
|----	|AVL平衡二叉树	|log(n)	|log(n)	|log(n)	|log(n)		|log(n)		|log(n)	|是	|用BF平衡因子绝对值不大于1进行二叉树平衡，保证性能稳定
|----	|RBT红黑树	|log(n)	|log(n)		|log(n)		|log(n)		|log(n)		|log(n)		|是		|用。。。进行二叉树平衡，保证性能稳定
|**B树**	|2-3树	|log(n)		|log(n)		|log(n)		|log(n)		|log(n)		|log(n)		|是	|结点存放多个关键词，降低树高，减少查询次数，如2-3树，2-3-4树等
|**B树变种**	|B+树	|		|		|		|		|		|		|是	|叶子存放关键词，非叶子结点只用于索引，并且每个叶子结点存放链接后一个叶子结点的指针
|----	|B*树	|		|		|		|		|		|		|是	|为B+树的非叶子结点也增加链表指针，将结点的最低利用率从1/2提升到2/3
|**hash表查找**	|hash表查找	|		|		|		|		|		|		|否	|

### 顺序表查找
---
顺序查找又叫线性查找，查找空间是线性的、无序的。

#### 朴素的顺序表查找方法

* 从数组头部开始向尾部查找，如果等于目标则输出并结束，查找不到则结束。

#### 顺序表查找优化

* 如果a[0]等于key则返回
* 否则设置a[0]=key；i=n；while(a[i]!=key) {i--;} return i;

* 思想就是用key截断查找方向，好处在于不用每次都比较i是否超出n长度，可以有小幅度优化。当然也可以a[n-1]=key，从小向大查找。

### 有序表查找
---
线性表有序时，进行查找可以利用顺序信息进行有效的优化。

#### 二分查找（折半查找）

* 关键思想：中间数比较，等于则输出；不等于则确定对左边或右边进行二分查找
* 时间O阶O(log(n))

#### 插值查找

* 在二分查找中，对下一级的半部分进行查找时选用的是头和尾的0.5，如果将0.5改为（key-a[low]）/（a[high]-a[low]），就叫插值查找。
* 插值查找时间O阶O(log(n))
* 对于数据多、数据分布均匀的情况，插值查找效率比二分查找高。对于数据不多、分布不均匀的情况，二分查找比插值查找要好。

#### 斐波那契查找

* 使用斐波那契序列取代二分查找中的的二分定位方法

### 线性索引查找
---
索引查找长用于数据库、文件、搜索引擎等领域。

#### 稠密索引

* 稠密索引：为每个数据建立索引，对索引进行二分、插值等查找。
* 数据量很多的时候不现实

#### 分块索引

* 分块索引：将数据分块有序，块内无序，块间有序。
* 对每个块建立索引，查找的时候先查找块，然后内部进行顺序查找。

#### 倒排索引

* 倒排索引：用次关键字对主关键字记录建立索引的方式。
* 如对于good friend、good boy、a girl建立索引时用a对应3，good对应1,2，friend对应1，boy对应2，这样查找的时候就直接使用属性值的值查找记录，非常高效，即用属性值确定记录的位置。
* 倒排索引的优点是查找记录非常快，缺点是记录号不定长，且单词表在很长或者增删时都需要进行处理。常用于所有引擎的候选框等。
* 一般可以通过限定主键记录长度，记录编码压缩为110、+3等方式表示110、114等优化索引大小。

### 二叉排序树与平衡二叉树
---
**二叉查找树的缺点在于每个节点只存放一个元素值，每个节点最多有2个分支**，导致大数据的时候，树会很高很大，查找需要多次循环。

#### 二叉排序树（二叉查找树）BST

* 二叉排序树，Binary Search Tree，BST，也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）
* 二叉排序树：左子树的结点为空或者均小于根节点的值，右子树的结点为空或者均大于根节点，对左右子树进行递归要求。
* 二叉排序树的中序遍历就是所有结点从小到大。
* 查找方法：从根节点比较，相等则退出，否则对左右子树进行递归查找（与根的大小比较决定左还是右）。最外层有个循环控制是否查找不到。（将查找到的叶子结点返回以方便进行插入操作）
* 插入方法：查找判断，此时返回指针对应应该插入的叶子结点，已存在则不插入，不存在则比较是在左还是右新增结点。
* 删除方法：如果是其右子树为空则接上其左子树为左子树，如果其左子树为空则接上其右子树为其右子树，如果左右子树都不是空，则循环选取左子树中的右子树到结点即为左子树最大值，将最大值赋值给要删除的结点，将这个最大值结点释放，重接最大值的上下（判定删除的左子节点是不是最大的）。
* 二叉排序树在构造过程中，虽然是动态表，但是不会移动各个根节点，所以树的形状和插入顺序有很大关系，可能是斜树等情况，不够平衡。

#### 平衡二叉树 AVL

* AVL树，平衡二叉树，AVL出自是论文作者名。
* 由于二叉排序树的形状数据插入的先后影响可能导致偏差，因此需要构造平衡稳定的二叉树将性能稳定下来。
* 平衡二叉树 Self-Balancing Binary Search Tree或者叫 Height-Balanced Binary Search Tree，属于二叉排序树
* 平衡因子BF：Balance Factor，指的是左子树深度-右子树深度。平衡二叉树要求BF的绝对值不超过1。
* 最小不平衡子树：插入一个结点后，距离插入节点最近且BF绝对值大于1的结点为根构成的子树，称为最小不平衡树。主要用于表示插入该节点后AVL可以进行重新构建平衡。
* 插入方法：每个结点都存储自己的BF，插入的时候，判断插入该叶子结点后是否出现最小Unbalance子树，如果出现BF为2说明左边多，需要右旋调整，如果出现BF为-2说明右边多，需要左旋调整。注意，如果最小Unbanlance子树的BF与其子树的BF符号相反，则需要先对该最小Unbanlance子树的子树进行一步旋转，再对该最小Unbanlance子树进行旋转平衡。

#### 红黑树

* Red-Black BST，参考文章[Balanced Search Trees](http://algs4.cs.princeton.edu/33balanced/)、[浅谈算法和数据结构:九平衡查找树之红黑树](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)
* 红黑树的应用十分广泛，在多种编程语言中被用作符号表的实现，如：Java的TreeMap,TreeSet，C++ STL的map,multimap,multiset等。
* B树在使用的时候非常麻烦，但是B树比BST多了平衡操作，将2-3树的平衡思想与二叉树结合起来就可以使用BST统一的分支处理，能够构建相对稳定的平衡树。
* 基于2-3树构建RBT的思想可以理解为：黑色链接用来链接普通的2-nodes节点。使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。也就是说将1个3结点的两个元素进行拆分，左边的值拉出来的结点设置为红色属性（存储的时候是每个节点都有颜色属性值，根节点为黑色）
* 红黑树具有且必须保持下列性质，否则需要进行平衡调节：
	* 每个结点是红色的或者是黑色的，根节点是黑色的。每个叶子结点是黑色的
	* 如果一个节点是红色的，那么他的两个子结点都是黑色的
	* 对每个节点，从他到其所有后代结点的简单路径上，均包含相同数量的黑色结点。
* 红黑树的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。而又是一种平衡树。
* 插入算法：递归向下查找应该添加结点的分支结点，新插入的结点颜色为红色，对于下面三种情况**依次**进行判断（flipColor是必须在后面的）：
	* 如果一个节点的左子节点位黑色，右子节点为红色，则进行左旋操作（向左旋）
	* 如果一个节点的左子节点为红色，而且该红色结点的左子节点也为红色，则进行右旋操作
	* 如果一个节点的左右子节点均为红色，则执行FlipColor操作，提升中间结点（将两个子结点红色设置为黑色，自己设置为红）。

```
public override void Put(TKey key, TValue value)
{
    root = Put(root, key, value);
    root.Color = BLACK;
}

private Node Put(Node h, TKey key, TValue value)
{
    if (h == null) return new Node(key, value, 1, RED);
    int cmp = key.CompareTo(h.Key);
    if (cmp < 0) h.Left = Put(h.Left, key, value);
    else if (cmp > 0) h.Right = Put(h.Right, key, value);
    else h.Value = value;

    //平衡化操作
    if (IsRed(h.Right) && !IsRed(h.Left)) h = RotateLeft(h);
    if (IsRed(h.Right) && IsRed(h.Left.Left)) h = RotateRight(h);
    if (IsRed(h.Left) && IsRed(h.Right)) h = FlipColor(h);

    h.Number = Size(h.Left) + Size(h.Right) + 1;
    return h;
}

private int Size(Node node)
{
    if (node == null) return 0;
    return node.Number;
}
```


* AVL树与RBT的比较：
	* AVL是严格的平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；
	* 红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低开销；在最坏的情况下，红黑树的高度不超过2lgN（以2为底）
	* 所以简单说，如果搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应选择红黑树。即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。
	* 红黑树与AVL树的调整平衡的实现机制不同，AVL靠平衡因子和旋转，红黑树靠节点颜色以及一些约定再加上旋转。因此，存在去掉颜色的红黑树后它不是AVL树，比如左子树都是黑的，右子树都是红黑相间的，这样整个树高度2n的时候，根节点的左右层数差可以到n。

### 多路查找树（B树）
---

* 多路查找树Multi-way Search Tree，允许每个结点存储M/2到M个关键字（结点利用率），非叶子结点存储指向关键字范围的子结点，以降低树的高度。
* **所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中。**

#### B树（B-树）

* B树，B-树，B-Tree（Balanced树,不是指Binary！）。结点孩子树数目最大的数目为B树的阶。B树是一种平衡的多路查找树。2-3树，2-3-4树都是特殊的B树。常用于减少定位记录的用时，常用于文件系统和数据库。
* 一个m阶的B树要求如下：
	* 如果结点不是叶子结点，该结点至少有2个子树
	* 每一个非根的分支结点都有k个孩子，本身包含k-1个元素值，其中k属于[(m+1)/2, m]，（子树分支在50% - 100% 阶）
	* 所有叶子结点处于同一高度
	* 所有结点上的k-1个元素将数据分为k段，分别指向子树，以进行查找操作。
* B树主要用于内外存交换，每次读取一个节点到内存，进行比较确定子树，读取子结点再进行比较等等。有些像多层索引，只不过索引匹配相等，树支持大小比较。

#### 2-3树

* [浅谈算法和数据结构: 八 平衡查找树之2-3树](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)
* 2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key
* 2-3查找树实现起来比较复杂。插入和删除操作也需要保证平衡性和结点利用率的范围限制问题，进行相应的左旋右旋、拆分等操作。
* 在2-3查找树基础上改进的红黑树不仅具有较高的效率，并且实现起来较2-3查找树简单。
* 2-3树只能包含2结点或者3结点，可以与2-3-4树比较。2结点就是自己有1个元素且其分支有0个或者2个。3结点就是自己有2个元素且其分支有0个或3个。

#### 2-3-4树

* 4结点就是自己有3个元素且其分支有0个或4个，0表示是叶子结点，4表示是被3个数分割为4段区间。


### B树变种
---
#### B+树

* [浅谈算法和数据结构: 十 平衡查找树之B树](http://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html)
* **B+树不是严格意义上的树形数据结构。**
* 在B-树基础上，为叶子结点增加链表指针，**所有关键字都在叶子结点中出现，**非叶子结点只作为叶子结点的索引。可以通过叶子结点间的链表关系直接遍历全部记录。
* B+树特别适用于范围查找，找到起始节点之后直接向后遍历取值。常用于文件系统、数据库等。
* B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针

#### B*树

* 在B+树基础上，为非叶子结点也增加链表指针，B*树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3（代替B+树的1/2）
* B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针


### hash表查找
---
hash（散列）适合处理关键字不相关的情况，直接将关键字去掉关联，查找的时候一步到位，时间O阶O(1)。需要注意的是hash函数的选择和hash冲突的处理方法。

#### hash函数的选择

* hash函数选择需要：计算简单、分布均匀
* 常用方法：
	* 直接定址法：
	* 平方取中法：
	* 数字分析法：
	* 平方取中法：
	* 折叠法：
	* 除留余数法：
	* 随机数法：


#### hash冲突处理

* 常用方法：
	* 开放定址法：
	* 再散列函数法：
	* 链地址法：
	* 公共溢出法：

#### hash查找

* 时间O阶：
	* 最好时是O(1)，也就是没有冲突时。
	* 但是平均O阶需要需要考虑hash函数的分布、冲突处理方法、hash表的装填因子（记录个数/hash表的长度）

## 排序
---

* 排序算法的分类：
	* 内排序、外排序（是否只使用内存）
	* 稳定排序、不稳定排序（主键相同的记录是否会保持排序前的顺序）
	* 比较排序与非比较排序

* 算法比较
	* 参考文章：[常用排序算法总结(一)](http://www.cnblogs.com/eniac12/p/5329396.html)

|分类|算法	|最坏时间O阶	|最好时间O阶	|平均时间O阶	|辅助空间O	|是否稳定	|思想	|适合场景	|比较	|改进|
|::	|::	|::	|::	|::	|::	|::	|::	|::	|::	|::	|
|简单算法	|**冒泡排序bubbleSort**	|$n^2$	|$n$  |$n^2$	|$1$	|稳定	|  |不太用	|经常最低效	|已有序flag、鸡尾酒排序（定向冒泡排序：排序方向从低到高与从高到低切换） |
|---	|**简单选择排序simple selection**	|$n^2$	|$n^2$  |$n^2$	|$1$	|稳定	|  |可用于topN问题	|略优于bubble	|	|
|---	|**直接插入排序straight	insertion**|$n^2$	|$n$  |$n^2$	|$1$	|稳定	|  |适用于基本有序或数量少	|略优于s selection	|若非基本有序,插入时要比较多次,可用二分查找插入	|
|改进算法	|**希尔排序shell**	|$n^2$	| $n^{1.3}$ |$nlg(n)\sim n^2$	|$1$	|不稳定	|  |第一个突破$n^2$限制的排序	|	|	|
|---	|**堆排序heap**	|$nlg(n)$	|$nlg(n)$  |$nlg(n)$	|$1$	|不稳定	|  |	|适用于topN问题	|	|
|---	|**归并排序merging**	|$nlg(n)$	|$nlg(n)$  |$nlg(n)$	|$n$	|稳定	|  |	|高效稳定	|递归与非递归	|
|---	|**快速排序quick**	|$n^2$	|$nlg(n)$  |$nlg(n)$	|$lg(n)\sim n$	|不稳定	|  |	|快速	|枢纽选取、交换策略	|
|以上都是比较排序，下面是非比较排序	|**计数排序Counting**	|$n+k$	|$n+k$  |$n+k$ 最大最小之间所有	|$n$	|稳定	|  |	|	|	|
|---	|**基数排序radix**	|$k* n$	|$k* n$  |$k* n$ k位数	|$n$	|稳定	|  |	|	|	|
|---	|**桶排序**	|$n^2$	|$n$  |	|$r+n$ r是桶个数|稳定	|  |	|	|	|	|


* 一个算法是否稳定常常与实现有关，比如简单选择排序，如果将最小(大)值进行交换可能导致不稳定，如{5,5,2}，但是如果新开辟数组添加{2,5,5}就可以是稳定的。
* 比较排序的分类：
	* 插入排序：直接插入排序 —— 希尔排序
	* 交换排序：冒泡排序 —— 快速排序
	* 选择排序：简单选择排序 —— 堆排序
	* 归并排序：归并排序
* 排序应用：
	* 算法没有好坏之分，只是适合的场景不同，需要考虑数据的初始排序状态、时间限制、空间限制、稳定性限制、算法特性等
	* 虽然改进算法比简单算法要复杂，但是一些情况下还是简单算法比较高效。如基本有序时用直插更高效。 










