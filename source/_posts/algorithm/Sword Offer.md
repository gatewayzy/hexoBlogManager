---
title: Sword Offer
comments: true
date: 2017-03-01 13:58:19
updated: 2017-03-01 13:58:04
categories: Algorithm
tags:
- Sword Offer
---

**说明：**《剑指offer》。
<!-- more -->

---
* 参考文章：

##  未分类

* 除法与乘法使用位运算<<、>>，以提高效率，但是注意溢出等问题。
* 精度问题，导致=0不能用=0，而是用绝对值小于一个小数
* 解决问题需要先处理特殊情况，考虑负面测试、边界测试，再进行功能测试。
* 树的优点在于：同时具有快速查找和快速移动，基本都是O(lgN)，算是对数组查找O(1)和删除O(n)以及链表查找O(n)和删除O(1)的折中（或者说是平衡）。
* 树的遍历：先序、中序、后续遍历常用递归实现（递归本身就是用栈实现的），可以用非递归的栈和循环实现。层次遍历用队列实现，存放各级并将出队节点的子节点入队尾。

### 查找：各种查找算法与特点

* s3 二维数组从左向右、从上到下递增，查找一个数？先一列一列确定是否在该列，然后在列中查找

### 字符串拷贝的移动问题：

* s4 字符串的replaceAll()？两个数组append等操作？主要是避免从前向后插入会导致后面的不停向后移动，是n*n的复杂度，解决方法是先申请好空间，从后向前进行append

### 链表

* s5 链表O(n)从后向前输出？使用stack栈，或者递归下一个list和输出头

### 树

* 前序遍历、中序遍历、后序遍历、宽度优先遍历，树的堆结构和红黑树等。
* s6 重建二叉树，根据前序遍历和中序遍历构建树，输出后序遍历等？由前序遍历确定根，由根在中序的位置找左右子树，在左右子树中用前序找根，递归求解。


### 栈和队列

* 栈是头进头出，队列是尾进头出
* s7 用两个栈实现队列功能，用两个队列实现栈的功能？栈要队列的入队就是栈的push，如abc，队列的出队时（a）将栈中所有元素pop并放到另一个栈cba，出栈一个就是出队，然后将遗留内容再全都转存到原栈中。主要就是利用转存，画一下出入方向比较清楚。

### 查找和排序
* s8 查找旋转数组中的最小值？如00120,1111,1320。特例处理：如已经有序等。前后和中间进行二分比较，确定在前后半段进行递归查找，但是如果三者相等，不确定在前在后，需要进行顺序查找。

### 递归与循环

* 递归存在大量的函数调用，书写简单但是效率不高，循环高效但是不容易写。
* s9 斐波那契数列，1,1,2,3...？直接递归f(n)会有大量重复计算，使用循环来存储中间变量可以提高效率变成On。如果是用数学公式分解为二维矩阵[1,1;1,0]的n次方问题，可以利用n次方的快速求解方法：是偶数则为n/2次方乘n/2次方，是奇数就是一次方*（两个偶次方的积）
* 拓展：主要是状态定义与状态转移方程。如青蛙一次跳1或2级，到n级的方法？就是f(n)=f(n-1)+f(n-2)。如果是青蛙一次可以跳1或2或..或n级，那么到n级的方法？数学归纳法就是2的n次方。如果是多个2乘1的纸覆盖2乘8的面积的方法几种？就是左上角横着，那么左下必是横着，变成了f6；如果左上角竖着就是变成了f7，所以就是f(n)=f(n-1)+f(n-2)。

### 位运算：

* s10 二进制中1的个数？简单是按位统计是否为1，但更好的是原数值-1再和原数位与，这样就去掉了最右边1以及之后，循环到为0，可统计出1的个数。
* 拓展：两个二进制需要几步转换相同？先是异或，再统计1的个数。判断是不是2的幂方？就是统计二进制中1的个数是否为1

### 代码完整性

* 代码完整性：功能正常、边界测试、负面测试
* s11 实现数值的整数次方pow函数？ 负面测试：底数为0（浮点数的0判断），功能方面：效率方面使用快速幂运算，如果指数是负数就是计算之后取倒数。
* s12 打印1到最大的n位数字？ 其实n的范围是一个陷阱，如果超出int或者long等常用整数，会比较麻烦，可以使用字符串或者数组表示一个数字，输出的时候需要考虑起始位的0字符不输出。一种方法是用字符模拟加1和进位输出操作。另一种简单的方法是使用**全组合**，全组合的典型解法是递归(回溯法)，对第一个数字选取所有取值情况，再分别对之后的几位数进行递归。对生成的各个字符串，从左向右从非‘0’开始输出。**全排列问题**，全组合不用考虑顺序，全排列需要考虑顺序，全排列可以先求解全组合，然后对全组合的结果两两交换位置，如123交换12得到213再换后面的得到231，123交换13得到321再换后面得到312，123交换23得到132不能再换后面。
* 对于n位数字问题，一定要注意范围，这时需要考虑大数问题，而字符串是简单有效的大数表示方法。
* s13 在O(1)的时间删除链表节点，在一个单向链表中只有一个头指针和一个节点指针？ 链表在删除一个节点的时候，先用O(n)查找到目标，再用O(n)从头查找到目标的上一个节点，所以费时，就是因为没有外部迭代器进行回退。一种解法是查找到目标，然后将下一个节点的数据复制到本节点，然后删除下一个节点，需要考虑是null、删除头部时要更新指针、删除尾部时不要复制的特殊情况。时间复杂度分析：查找一个是O(n)删除一个是O(1)，各个数据的概率是1/n，因此还是O(1)。
* s14 调整数组顺序使得基数位于偶数前面？ 用两个指针分别从前后向中间找，前后都是一旦遇到不符合要求的数则停止移动，进行交换，直到两个指针相遇，注意临界值。
* 拓展：如果是要将数组分为前正后负？前能被3整除后不能被3整除？其实这些都是同一个代码，只需要将上面2个指针的移动封装为对应的函数，同样的控制就可以了。主要是能不能考虑封装为函数的问题。

### 代码鲁棒性 Robust

* 鲁棒性是指：程序能够判断输入是否合乎规范，并对不合要求的输入正确处理。提高鲁棒性主要通过防御性编程。
* s15 查找链表中倒数第k个节点？ 先遍历出长度再遍历到目标要2次。如果只允许一次遍历呢？2个指针问题，一个先走k-1，另一个再开始走，二者一同走，当前者到达尾，后者就在倒数第k个位置。这时候，需要注意k<=0或者超出链表范围都应该返回null。
* 拓展：一次找到链表的中间节点？ 2个指针问题，一个一次走2，一个一次走1，前者到达尾时后者在中间节点（注意奇偶数）。判断一个链表是否形成了环形结构？ 2个指针，一个一次走2，一个一次走1，如果前者被后者追上了，说明有环，如果前者都到null了还没追上就是没有环。
* 当一个指针遍历链表不能解决问题的时候，可以考虑用两个指针来遍历。二者速度不同，或者一个先走上若干步。
* s16 反转链表，将单向链表进行反转？ 从前向后遍历，当前节点不为空时，如果next是空，说明已经当前是尾部，设置返回头结点，将当前节点的next设为上一个（所以需要新建一个节点存放pre）。
* s17 合并两个有序列表，将两个递增的链表合并为一个递增的链表？ 两个链表的head进行比较，值小的取出并截断为新的链表，使用递归进行合并。需要注意两个链表的null判断，递归中if第一个为null则直接返回第二个，else返回第一个。
* s18 树的子结构问题，两个二叉树A和B，判断B是不是A的子树（对应的值一致才行）？ 递归遍历查找大树中等于B的根节点的节点，然后再递归比较两个节点子树是否具有相同的各级节点。二叉树遍历经常需要考虑null的情况。

### 解决问题的思路
* 解决问题时常常通过画图、示例进行具体化，发现解决方法。
* s19 二叉树的镜像，对一个二叉树输出其镜像（左右完全反转）？ 从根节点输出，然后进行递归输出：当前节点的左右子节点交换并输出。如果是循环如何实现？树的遍历一遍使用栈或队列，这里像是层次遍历，使用队列进行。
* s20 顺时针从外向里打印m*n的矩阵？ 画图各种胖窄的形状，发现每一圈都输出上下左右一行一列，每次左上角都是（a，a），每一圈都是从不同的行数列数中输出顺时针四个方向的数据。画图发现一共的圈数满足2a小于列数和2a小于行数，所以每一圈的a进行输出，并根据相对的a和行列数判断后三个方向是不是退化到消失。（如最后一圈是1/1,3/1,1/3,1/2等情况，只要判断相对的起始位置即可确定是否头后3个方向）。
* s21 包含min函数的栈，如何使用栈实现使得插入、删除、获取时，能以O(1)的时间复杂度获取min？ 要求中每次插入一个数据之后，还是能以O(1)的时间获取栈中的min，只用一个stack是很难实现了，可以用一个辅助栈，辅助栈中专门存放与主栈同样高度时，主栈中的最小值。每当插入一个值时，辅助栈添加一个值，且取决于辅助栈顶值与新插入数据的最小值。每当pop一个数，主栈删除栈顶，辅助栈pop栈顶就是pop之前的min，之后的栈顶就是主栈pop之后的min。
* s22 栈的压栈、出栈序列，给定两个序列，第一个是入栈顺序，判断是否能构成第二个出栈序列（不考虑存在相同数字的情况）？  可以使用一个目标栈存放目标的出栈序列，这样相比使用数组更加方便。处理时，将入栈序列（可用数组存）不断进行入栈，记为主栈，并与目标栈的栈顶进行比较，如果相等则主栈pop，且目标栈pop，如果不相等，则主栈不断push直到与目标栈栈顶相同，如果入栈序列结束了但是目标栈还不是空，那么不可能生成目标序列。
* s23 从上向下分层打印二叉树，其中每层按照从左向右的顺序？ 典型的树的层次遍历问题，使用队列，保证先进先出。从根节点开始，添加节点到队列，并将其子节点添加到队尾，不断从队列头部取出节点，将其子节点添加到队尾，直到遍历万所有节点。 
* 拓展：如何广度遍历一个有向图？ 广度优先遍历使用队列实现，树是图的一种特殊退化，树的从上到下按层遍历本质上就是广度优先遍历二叉树。
* s24 二叉搜索树Binary Search Tree的后序遍历序列：输入一个整数数组，判断是不是某个BST的后序遍历序列，如{5,7,6,9,11,10,8}是不是一个BST的后序遍历？ 








