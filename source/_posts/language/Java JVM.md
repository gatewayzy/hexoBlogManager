---
title: Java JVM
comments: true
date: 2017-01-10 13:58:10
updated: 2017-01-10 13:58:56
categories: Language
tags:
- Java
- Language
---

**说明：**Java virtual machine，主要来自《深入理解Java虚拟机》，有关java内存如何分配，类加载过程等。
<!-- more -->


参考文章：
* 《深入理解Java虚拟机》


### jvm内存分配、垃圾收集策略
---

java内存分配有线程共享内存、线程私有内存。GC主要发生在Java堆。

#### 线程共享区域
* 方法区 Method Area：存储类信息（Class文件）、运行时常量池、静态变量（static）等
	* Class文件包括：类的版本、字段、方法、接口、常量池（称为Class文件常量池，存放类在编译后得到的各种字面量和符号引用）
	* 运行时常量池：Class文件常量池在类加载（大约在解析阶段）时，将符号引用和解析后的直接引用都放到运行时常量池中。
		* Class文件常量池在编译后就固定了，但是运行时常量池经过类加载解析后，还是可变的。如String a="a";a.intern();就是添加到运行时常量池。
	* 常量池中的4类符号引用（类或接口、字段、类方法、接口方法）对应着4种常量类型CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info。
	* GC：方法区一般又叫“永久代”，但是实际上是可以GC的，只不过GC起来会很麻烦，主要是回收常量池、卸载类。
* 堆 Heap ： 存放所有对象实例和数组（不绝对），占很大内存，GC发生的主要区域。	

#### 线程私有区域
* 虚拟机栈 VM Stack：不同方法对应不同栈帧，依靠栈运行方法。栈帧里面有局部变量表、动态链接、方法出口等信息
* 本地方法栈： 与虚拟机栈功能相似，有的直接将二者统一为一个栈。本地方法栈运行Native Method，虚拟机栈运行Java方法即字节码服务。
* 程序计数器 PC Register

#### GC 垃圾回收机制
* 对象存活性判断：引用计数法、可达性分析法（由GC Roots（含类的静态属性、栈引用的对象）进行Trace）。
* 引用强弱：强、软、弱、虚引用。GC发生时，强引用对象不可删；软就是有用但是不必要，第一次GC别删，第二次GC可删；弱就是第一次GC就可回收该对象；虚表示无用，用于对象被GC时可以收到一个系统通知。
* GC算法：标记-清除算法、复制收集算法（常用于新生代）、标记-整理算法（常用于老年代）
* 堆分为新生代和老年代。新生代有Eden、From survivor、To Survivor（如比例8:1:1），GC他叫Minor GC，很频繁但很快；老年代GC叫Major或Full GC，不频繁但是慢Minor GC要10倍以上。
* 内存分配与GC的策略：
	* 新对象优先分配到新生代的Eden和From：二者占90%。这个0.9不够就GC：Eden和From用复制算法到To，To够用就拷贝回Eden，To不够用需要老年代的担保机制。
	* 大对象直接接入老年代：大量连续内存的对象（如数组和字符串）直接放老年代。
	* 长期存活的对象进入老年代：使用存活过的GC次数计数Age。
	* 动态判定对象年龄：年龄Age都比较大或比较小，就可设置阈值，存活久的放老年代。
	* 空间分配担保：Minor GC之前，如果老年代有连续空间大于所有新生对象，那Minor GC肯定安全，因为老年代担保；但是如果老年代没有这么大连续空间，需要设置是否冒险。允许冒险且新生空间小于经验值，则尝试Minor GC，大不了放老年代；如果不允许或者允许冒险但是需要太大，则老年代GC保证肯定够新生用。
* 常见GC收集器：stop the world 问题、标记、清除、整理
	* 新生代的Serial、ParNew、Parallel Scavenge
	* 老年代的CMS、Serial Old、Parallel Old
	* 实验性G1


### java代码编译和执行的整个过程
---
java从编译到执行经过3个重要机制：源码编译机制、类加载机制、类的执行机制。

### 源码编译机制
---
* Java 源码编译由以下过程组成：分析和输入到符号表、注解处理、语义分析和生成 class 文件
* Class文件
	* class文件由01字节码组成，以字节为基础单元，是一种没有任何分隔符的字节流。各种运行在jvm之上的语言也都是编译生成class文件。class文件包括无符号数和表，根据jvm规范进行严格的解析。
	* class文件格式：
		* **class版本号**：magic/u4、minor_version/u2、major_version/u2，  4字节表magic确定class与jvm兼容性，2字节表次版本号，2字节表主版本号。
		* **常量池**：constant_pool_count/u2、constant_pool/cp_info,  2字节表常量数量(class唯一一个从1计数的count)，cp中存放**字面常量（字符串、final的常量等java常量）和符号引用（类和接口的全限定名、方法的名称和描述符、字段的名称和描述符）**。
		* **访问标志**：access_flag/u2, 2字节数值对应到该类或接口否为类或接口、是否为public、是否为abstract、是否final等信息的编码。
		* **类、父类、接口的索引**：this_class/u2、super_class/u2、interfaces_count/u2、interfaces_count/u2， 分别确定this类、父类和接口的全限定名。由于单一继承，因此除了java.lang.Object，其他类的super都不是0且唯一。由于多接口（类implements接口或接口extends接口），接口索引是个集合，根据定义时的从左向右放入集合中。
		* **字段表集合**：fields_count/u2、fields/fields_info，  java变量类型--类级变量（类的非static变量）、实例级变量（类的static变量）、局部变量（方法内部的变量）。字段表集合描述了类级变量和实例级变量的信息：字段作用域（public private protected）、是否实例级变量（static）、是否可变（final）、并发可见性（volatile要求强制从内存读写）、是否被序列化（transient）、字段数据类型（基本类型、对象、数组）、字段名称。具体表示使用复用access_flags编码、u2数据集合。
		* **方法表集合**：methods_count/u2、methods/method_info，  方法表集合的定义和字段表类似，但是volatile和transient不能修饰方法，而synchronized、native、strictfp、abstract可以修饰方法，所以取值稍微有些变化。此外，方法的代码所编译生成的部分存放在属性表集合的Code属性中。对于重载overload，class文件格式的特征签名包括了返回值、参数等修饰符，所以是支持仅有返回值不同的重载，但是java语言的特征签名不包括返回值，因此不支持仅有返回值不同的重载。
		* **属性表集合**：attributes_count/u2、attributes/attribute_info，  属性表集合用于存放专有的信息，class文件、字段表、方法表都可以在属性表集合中添加相应的数据。Code属性可以存放方法表中的方法的详细内容，ConstantValue存放字段表的final定义的常量，Deprecated属性存放deprecated的类、方法表、字段表，Exceptions属性存放方法表的异常信息等等，属性表内容非常广泛。
* 字节码指令：
	* jvm使用一个字节长度、代表着某种特定操作含义的数字表示操作码以及0到多个操作数构成指令。jvm指令是面向操作数栈而不是面向寄存器的架构。
	* 优点在于：放弃操作数对齐，指令集不必进行填空和间隔，操作码都是0-255之间的数字表示，短小精悍。
	* 缺点在于：如果操作数长度超过一个字节，需要运行时从字节重构出具体数据，导致解释执行字节码时有一定性能损失。
* JIT 编译
	* Java 程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。
	* 后来虚拟机引入了 JIT 编译器（即时编译器just in time），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是 JIT 编译器。
	* 由于JIT编译器的引入，java从“解释执行”语言，添加了“编译执行”的语言特性。

### 类的加载机制
---
* java语言编译时不需要进行连接工作，所以得到的class文件不能直接在内存中运行。java语言中，类型的加载、连接和初始化操作是在程序运行期间完成的，这种策略虽然会有一定性能开销，但是可以为java应用程序提供高度灵活性。java的动态拓展性就是依赖于运行期动态加载和动态连接实现的。这一特性常用于：面向接口编程，在运行时再指定其实现类；通过java加载器或者自定义加载器，让程序在运行时加载一个class文件到程序中。

#### 类的加载器
* 类的加载器是什么？为什么？怎么做？
* 类的加载器：通过一个类的全限定名来获取描述该类的二进制字节流的模块。这个动作放在jvm外部去实现，让应用程序自己决定如何获取所需要的类。
* 类在jvm中的唯一性是通过类加载器的类名称空间+类本身共同确定的，不同的类加载器加载的同一个类是不相等的（equals）。
* 类加载器：
	* Bootstrap ClassLoader 启动类加载器，使用C++实现，使用java访问到的是null。负责加载<JAVA_HOME>\lib目录特定文件。
	* Extension ClassLoader 扩展类加载器，负责加载<JAVA_HOME>\lib\ext目录，用户可以直接使用。
	* Application ClassLoader 应用程序类加载器，也成为系统类加载器，负责加载用户类路径Classpath的指定类库，可以直接使用，没有定义自己的类加载器时会默认使用该加载器。
	* Customer ClassLoader 用户自定义类加载器，只要extends java.lang.ClassLoader，重写loadclass(),如 Tomcat、jboss 都会根据 J2EE 规范自行实现 ClassLoader.
* 虽然这几个类加载器之间有父子关系，但是不是通过继承方式实现的，而是通过组合方式（代码内部控制）实现的。除了启动类加载器是c++写的，其他加载器都需要继承java.lang.ClassLoader。
* 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是将请求委派给父类加载器，每一个加载器都如此；一旦遇到一个加载器已经加载该类，就视为已加载此类，保证此类只被加载一次；如果父加载器反馈自己无法加载目标类时，子加载器才会尝试自己去加载。

#### 类加载
类加载的过程：加载、验证、准备、解析（这三者统称为连接）、初始化。正常使用、卸载。
* **类的加载**：加载器加载类的二进制字节流（Class文件）。
* **类的验证**：验证class文件的格式规范、元数据、字节码、符号引用等是否安全有效。
* **类的准备**：为类变量（static变量）分配内存并设置类变量初始值，这些内存都在方法区。但是实例变量是不在这里的，实例变量如 private int a 会随着实例对象放在堆中。而且初始值是jvm内部默认的类型初始值，如数值初始为0，引用初始为null，如int a=3初始化为0，只在初始化的`<clinit>`()中才会进行类变量赋值变成3。但是如果是 static final的ConstValue则会直接分配并设置为指定的初始值，再也不会改变。
* **类的解析**：虚拟机将常量池中的符号引用转化为直接引用的过程。（Class文件中的常量池解析到运行时常量池、方法的静态解析等工作）
* **类的初始化**
	* 类的初始化是什么？为什么？怎么做？
	* 类的初始化：执行类构造器`<clinit>`()方法。用于执行程序中的初始化操作和其他资源。问题在于什么是类构造器`<clinit>`()。
	* 类构造器`<clinit>`()方法：
		* **`<clinit>`()方法是编译器自动收集类中的所有类变量的赋值动作和静态代码块（static块）的语句合并产生的**，收集顺序与程序编写顺序有关。static块只能访问定义在其之前的变量，对于定义在其后面的变量只能进行赋值，而不能访问，否则就是非法向前引用。
		* `<clinit>`()方法与类的构造函数（实例构造器<init>()）不同，`<clinit>`()不需要显示调用父类的`<clinit>`()，虚拟机会自动保证在子类的`<clinit>`()执行之前，已经执行完成父类的`<clinit>`()。
		* `<clinit>`()总是先完成父类的`<clinit>`()，也就是先完成父类的类变量赋值、static{}。
		* 一个类并不总是需要有`<clinit>`()，如果没有类变量赋值和static{}，编译器可以不生成其`<clinit>`()。
		* 接口中没有static{}，但还是有类变量赋值，所以也是有`<clinit>`()，但子接口和实现类不需要调用父接口的`<clinit>`()，除非使用到了父接口（如访问父接口的变量）。
		* 虚拟机可以保证`<clinit>`()在多线程时也被正确的加锁、同步，多线程初始化一个类时，会同步锁，只有一个线程执行`<clinit>`()，其他需要阻塞等待，所以`<clinit>`()太繁重也会造成长时间阻塞。
	* 类的初始化时机有且只有5种情况（称为主动引用）：
		* 遇到new、getstatic、putstatic、invokestatic这4个字节码指令时，如果类没有进行过初始化，必须先对其初始化。常见场景是：使用new创建实例对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法。
		* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，需要进行初始化。
		* 当初始化一个类的时候，如果其父类没有初始化，需要先对其父类初始化。*但是一个接口在初始化时，并不要求其接口已经初始化，只有在真正使用到父接口的时候才会进行父接口的初始化（虽然没有static静态语句块，但是也有变量初始化赋值）。另外，接口的实现类在初始化时也不要求接口初始化。*
		* jvm启动时，用户需要指定一个要执行的主类（含有main()方法的那个类），jvm会先初始化这个主类。
		* 当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，而该方法句柄对应的类没有进行初始化，则需要先触发其初始化。
	* 除了5种主动引用，其他都是被动引用，不会触发类的初始化，比如：子类引用父类的静态字段，不会导致子类初始化；通过数组定义来引用类，不会触发数组类的初始化；常量在编译时存入调用类的常量池，本质上没有直接引用定义类，不会触发定义常量的类的初始化。

* java代码运行 
	* --》  jvm需要加载运行主类main()，自底向上检查该类是否已经加载，发现该类未加载 
	* --》  自顶向下调用加载器尝试加载类，类加载时会开始验证、准备、解析操作，但是各阶段结束先后不确定 
	* --》  从Object向下加载了很多类，当前类也加载完成  
	* --》  尝试初始化：运行本类的clinit方法（对类变量赋值和static{}代码块），但是发现父类的clinit尚未执行 
	* --》  于是需要先完成父类的clinit，一直向上查找运行clinit，所以一定是Object类最先完成clinit。但是注意子接口或者实现类不需要执行父接口的clinit，只在使用到时才初始化  
	* --》  自顶向下完成了clinit  
	* --》  运行程序，遇到主动引用时进行类加载检验。


### 类的执行机制
---
虚拟机执行涉及到栈帧结构、方法调用、字节码执行。

#### 栈帧和方法计数器
	* JVM 是基于栈的体系结构来执行 class 字节码的。
	* 线程创建后，都会产生程序计数器（PC）和栈（Stack，虚拟机栈和本地方法栈）
		* 程序计数器存放下一条要执行的指令在方法内的偏移量
		* 栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。

####  方法调用
---
* 方法调用并不是方法执行，方法调用的目的是确定被调用方法的版本（到底运行哪一个方法）。
* 方法执行是在方法调用确定了方法之后，执行方法的代码，执行方式有解释执行（java主要用基于栈的字节码解释执行引擎）和编译执行（java也有JIT等编译器）。
* 方法调用的方式有解析、分派。
* jvm共提供了四条方法调用的字节指令，分别是：
	* invokestatic：调用静态方法。
	* invokespecial：调用实例构造器方法、私有方法和父类方法。
	* invokevirtual：调用所有的虚方法。
	* invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。

##### 解析 Resolution
* 方法解析又叫方法的静态解析，静态调用。静态解析是指： Class 文件的符号引用在**类加载阶段或第一次使用时**转化为直接引用。
* 静态解析成立的前提是：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，也就是方法具有“编译器可知，运行期不可变”的特点。换句话说，调用目标（方法）在编译器进行编译时就必须确定下来（运行时不会再改变），这类方法的调用称为方法解析。
* 解析调用一定是个静态过程，在编译期间就完全确定对应的方法，在**类加载的解析阶段**就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成方法调用。
* 只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载时就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法就称为虚方法。非虚方法都可以通过解析实现方法调用。
* 注意：特别地，final 方法是一种非虚方法，它使用的是 invokevirtual 指令，但是由于它无法覆盖，没有其他版本，所以也无需对方发接收者进行多态选择。final方法属于非虚方法，可以通过解析实现方法调用。
	

##### 分派 Dispatch
* 分派调用可能是静态的也可能是动态的，根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。
* 动态连接
	* Class 文件的符号引用在每一次的运行期间转换为直接引用。
	* 这个特性给 Java 带来了更强大的动态扩展能力，使得可以在类运行期间才能确定某些目标方法的直接引用。
* 分派机制是多态性的实现机制。目前的 Java 语言是一门静态多分派、动态单分派的语言，但也在增加一些动态语言特性，如jdk1.7增加invokedynamic指令等。
* **静态分派**
	* 静态分派：根据静态类型来定位方法的执行版本的方法分派。最典型应用就是多态性中的方法重载 overload。
	* 静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。
	* Human man = new Man();hi(man);
	* 我们把上面代码中的“Human”称为变量的静态类型，后面的“Man”称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的（如hi((Man)man);//强制变换静态类型为Man，但man本身的静态类型仍是Human，之后再用还是Human），而实际类型变化的结果在运行期才可确定（如 man=new Woman();//静态类型不变但是实际类型变Woman，之后以Woman使用）。
	* 重载等静态分派是通过静态类型和参数个数定位方法的，所以这里hi(man)调用hi(Human h)方法，与man的实际类型Man无关。所以hi(new Human())、hi(new Man())、hi(new Woman())分别静态分派到hi(Human h)、hi(Man h)、hi(Woman h)，没有对应方法是无法编译通过的。
	* 重载的结果可能并不唯一，比如hi('a')，由于字面量'a'没有显式的静态类型，所以可能会先后尝试重载到hi(char)/hi(int)/hi(long)等等方法。只要有显式的静态类型，没有对应的方法就只能通不过编译了。
* **动态分派**
	* 动态分派：在运行期根据实际类型确定方法执行版本的分派。最典型应用就是多态性中的方法重写 overwrite。
	* Human man2 = new Man(); Human woman2 = new Woman(); man2.get(); woman2.get();
	* 二者的静态类型都是Human，如果使用静态分配就无法访问子类中的不同方法。动态分派在运行期根据实际类型确定方法执行版本。
	* 在这里，程序运行时使用invokevirtual字节码指令解析程序，其方法调用基本流程为：取操作数栈顶的栈顶元素的**实际类型**，如果能找到相符的方法则进行访问验证，验证失败则抛出异常，验证通过则返回其直接引用；如果找不到相符的方法，则按照对象的继承关系**自底向上**查找其父类对应的方法，并进行验证。直至结束或者异常。这就是动态分派和重写的本质。
* **单分派与多分派**
	* 方法的接受者（即方法的调用者）与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。
	* java中，静态分派（如重载）区分参数（个数、类型），也区分调用者的静态类型，区分2个宗量，所以java是静态多分派。比如Integer.toString()和Long.toString()肯定是类型信息和参数信息均有效。
	* java中，动态分派（如重写）由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），可以影响方法的选择的只有调用者的实际类型，只有一个宗量作为选择依据，所以 Java 语言的动态分派属于单分派类型。（即使有静态分派，动态分派也在静态分派之后）


### 语法糖
* 语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。
* Java 中最常用的语法糖主要有*泛型、变长参数、条件编译、自动拆装箱、内部类*等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程称为解语法糖。














