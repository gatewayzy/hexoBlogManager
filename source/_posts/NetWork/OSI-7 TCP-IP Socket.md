---
title: OSI 7层网络模型与TCP/IP模型
comments: true
date: 2017-09-01 13:58:10
updated: 2017-09-01 13:58:10
categories: Network
tags:
- OSI
- TCP/IP
- Socket
---

**说明：**计算机网络的OSI7层网络模型，与TCP/IP模型。
<!-- more -->


参考文章：
[OSI网络HTTP、TCP、UDP、Socket 知识总结](http://www.cnblogs.com/chengzhengfu/p/4584510.html)

## OSI七层模型


![image](http://zcy.ckcest.cn/cdn/zy/20170906-Image-1.jpg)

OSI模型共有七层，分别为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层,也被依次称为 OSI 第一层、第二层、⋯⋯、 第七层。
* 物理层、数据链路层和网络层通常被称作媒体层，是网络工程师所研究的对象；
* 传输层、会话层、表示层和应用层则被称作主机层，是用户所面向和关心的内容。

 　　http协议   对应于应用层 
 　　tcp协议    对应于传输层  
 　　ip协议     对应于网络层 
 　　三者本质上没有可比性。何况HTTP协议是基于TCP连接的。 
　　TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。

* 我们在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容.
* 如果想要使传输的数据有意义，则必须使用应用层协议，应用层协议很多，有HTTP、FTP、TELNET等等，也可以自己定义应用层协议。WEB使用HTTP作传输层协议，以封装HTTP文本信息，然后使用 TCP/IP 做传输层协议将它发送到网络上。
* Socket是对 TCP/IP 协议的封装，Socket 本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP 协议。


## TCP/IP 模型
![image](http://zcy.ckcest.cn/cdn/zy/20170906-Image-2.jpg)
TCP/IP 模型分为四层,由下而上分别为网络访问层、网际层、传输层、应用层。
TCP/IP 由于有较少的层次,因而显得更简单,并且作为从因特网(INTERNET)上发展起来的协议,已经成了网络互连的事实标准。

## Http和Socket连接区别
* 短连接 
　　连接->传输数据->关闭连接 
　　HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
　　也可以这样说：短连接是指 Socket 连接后发送后接收完数据后马上断开连接。
* 长连接 
　　连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 
　　长连接指建立 Socket 连接后不管是否使用都保持连接，但安全性较差。 

* http的长连接  　
　HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。

* 什么时候用长连接，短连接？
	* 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理 速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成 Socket 错误，而且频繁的 Socket 创建也是对资源的浪费。 
	* 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接 会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下 需用短连好。 
	* 总之，长连接和短连接的选择要视情况而定。

### HTTP连接

* HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。

* HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。
    1. 在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
    2. 在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。
* 由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

### Socket
Socket 是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。首先让我们通过一张图知道Socket在哪里？

![image](http://zcy.ckcest.cn/cdn/zy/20170906-Image-3.jpg)

#### 套接字（Socket）概念
* 套接字（Socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：**连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口**。
* 应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

#### 建立Socket连接
* 建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。
* 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
    * 服务器监听 listen：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
    * 客户端请求 syn：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
    * 连接确认 ack：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，**建立一个新的线程**，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

#### Socket连接与TCP、UDP连接
* 常用的Socket类型有两种：
    * 流式Socket（SOCK_STREAM）：流式套接字是一种面向连接的 Socket，针对于面向连接的TCP服务应用；
    * 数据报式Socket（SOCK_DGRAM）:数据报式 Socket 是一种无连接的 Socket ，对应于无连接的UDP服务应用。

#### Socket连接与HTTP连接
* 由于通常情况下 Socket 连接就是TCP连接，因此 Socket 连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

* HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
* 很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

## 基于Socket实现TCP架构

* 基本TCP客户—服务器程序设计基本框架，如下图。

![image](http://zcy.ckcest.cn/cdn/zy/20170906-Image-4.jpg)
　　
* 整个TCP连接过程：三次握手建立连接、数据传输、四次挥手释放连接。如下图。

![image](http://zcy.ckcest.cn/cdn/zy/20170906-Image-8.jpg)


### socket状态说明
* windows和linux都可以使用netstat命令查看网络端口连接状态。
* linux推荐更好的ss命令（socket status）、`lsof -i :808`·。
	- LISTENING状态
		- server（记为我方）启动后首先处于侦听（LISTENING）状态。
	- ESTABLISHED状态
		- ESTABLISHED的意思是建立连接。表示两台机器正在通信。
	- CLOSE_WAIT
		- 对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭
	- TIME_WAIT
		- server主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。
* socket状态说明
	- CLOSED	没有使用这个套接字[netstat 无法显示closed状态]
	- LISTEN	套接字正在监听连接[调用listen后]
	- SYN_SENT	套接字正在试图主动建立连接[发送SYN后还没有收到ACK]
	- SYN_RECEIVED	正在处于连接的初始同步状态[收到对方的SYN，但还没收到自己发过去的SYN的ACK]
	- ESTABLISHED	连接已建立
	- CLOSE_WAIT	远程套接字已经关闭：正在等待关闭这个套接字[被动关闭的一方收到FIN]
	- FIN_WAIT_1	套接字已关闭，正在关闭连接[发送FIN，没有收到ACK也没有收到FIN]
	- CLOSING	套接字已关闭，远程套接字正在关闭，暂时挂起关闭确认[在FIN_WAIT_1状态下收到被动方的FIN]
	- LAST_ACK	远程套接字已关闭，正在等待本地套接字的关闭确认[被动方在CLOSE_WAIT状态下发送FIN]
	- FIN_WAIT_2	套接字已关闭，正在等待远程套接字关闭[在FIN_WAIT_1状态下收到发过去FIN对应的ACK]
	- TIME_WAIT	这个套接字已经关闭，正在等待远程套接字的关闭传送[FIN、ACK、FIN、ACK都完毕，这是主动方的最后一个状态，经过2MSL时间后变为CLOSED状态]
* 其他状态说明
	* connect返回-1 
		* errno=110(ETIMEDOUT)，当服务器端网线拔了的时候，客户端发送SYN过去就会收不到ACK，因此就会出现这个错误，1分钟内就会返回这个错误。error no = 110
		*  errno=111(ECONNREFUSED)，当服务器未listen时，就会报这个错
	* ESTABLISHED不一定真的establish
     	* 这是因为LINUX不像其他操作系统在收到SYN为该连接立马分配一块内存空间用于存储相关的数据和结构，而是延迟到接收到client的ACK，即三次握手真正完成后才分配空间，这是为了防范SYN flooding攻击。 如果是这种情况，那么就会出现**client端为ESTABLISHED状态，server为SYN_RECV状态**。 
     	* 并且server的SYN_RECV状态在一定时间后会消失，client的established状态也会消失。这是因为server在SYN_RECV状态时，会像client发送多次的SYN+ACK（因为他以为自己的这个包对方没收到），发送的次数定义在/proc/sys/net/ipv4/tcp_synack_retries中，默认为5。在发送5次之后还没有收到ACK，就将其回收了，所以用netstat查看就看不到这个SYN_RECV状态了。并且会向client发送RST信号。这就会导致client的这种半连接状态也会消失。

### TCP三次握手
相对于SOCKET开发者，TCP创建过程和连接拆除过程是由 TCP/IP 协议栈自动创建的。因此开发者并不需要控制这个过程。但是对于理解TCP底层运作机制，相当有帮助。

所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在 Socket 编程中，客户端执行connect()时。将触发三次握手。 
* client发起一个seq=x的包，且syn标志位为1，表示是个syn请求
* server发送一个seq=y的包，且syn标志位为1，表示是个syn应答，并ack=x+1
* client发送一个seq=x+1的包，且ack=y+1，表示是个ack包，而syn标志位为0表示不是同步包。

![image](http://zcy.ckcest.cn/cdn/zy/20170906-Image-6.jpg)


## TCP四次挥手
TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

为什么连接的时候是三次握手，关闭的时候却是四次挥手？

    * 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来 同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，” 你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

![image](http://zcy.ckcest.cn/cdn/zy/20170906-Image-7.jpg)


## 基于Socket实现UDP架构
* 基本UDP客户—服务器程序设计基本框架流程图
![image](http://zcy.ckcest.cn/cdn/zy/20170906-Image-5.jpg)




## 协议的区别

### TCP、UDP、HTTP、SOCKET之间的区别
- TCP和UDP：传输层协议；
- HTTP：应用层协议；
- SOCKET：TCP/IP网络的API。
- TCP/IP代表传输控制协议/网际协议，指的是一系列协议。
- TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。
- TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。
- TCP和UDP是FTP、HTTP和SMTP之类使用的传输层协议。
- HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。
- 客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。
- 记住，需要IP协议来连接网络;TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。
- Socket 接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，用以开发TCP/IP网络上的应用程序。

### tcp和udp的区别
* TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。
* UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。由于是面向无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一 起，这样的数据是没有意义的。

